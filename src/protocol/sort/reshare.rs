use crate::ff::Field;
use crate::protocol::context::SemiHonestContext;
use crate::{
    error::Error,
    helpers::{Direction, Role},
    protocol::{context::Context, RecordId},
    secret_sharing::Replicated,
};
use embed_doc_image::embed_doc_image;

/// Reshare(i, \[x\])
// This implements reshare algorithm of "Efficient Secure Three-Party Sorting Protocol with an Honest Majority" at communication cost of 2R.
// Input: Pi-1 and Pi+1 know their secret shares
// Output: At the end of the protocol, all 3 helpers receive their shares of a new, random secret sharing of the secret value
#[derive(Debug)]
pub struct Reshare<F: Field> {
    input: Replicated<F>,
}

impl<F: Field> Reshare<F> {
    pub fn new(input: Replicated<F>) -> Self {
        Self { input }
    }

    #[embed_doc_image("reshare", "images/sort/reshare.png")]
    /// Steps
    /// ![Reshare steps][reshare]
    /// 1. While calculating for a helper, we call pseudo random secret sharing (prss) to get random values which match
    ///    with those generated by other helpers (say `rand_left`, `rand_right`)
    ///    `to_helper.left` knows `rand_left` (named r1) and `to_helper.right` knows `rand_right` (named r0)
    /// 2. `to_helper.left` calculates part1 = (a1 + a2) - r2 = Same as (input.left() + input.right()) - r1 from helper POV
    ///    `to_helper.right` calculates part2 = (a3 - r3) = Same as (input.left() - r0) from helper POV
    /// 3. `to_helper.left` and `to_helper.right` exchange their calculated shares
    /// 4. Everyone sets their shares
    ///    `to_helper.left`  = (part1 + part2, `rand_left`)  = (part1 + part2, r1)
    ///    `to_helper`       = (`rand_left`, `rand_right`)     = (r0, r1)
    ///    `to_helper.right` = (`rand_right`, part1 + part2) = (r0, part1 + part2)
    pub async fn execute(
        self,
        ctx: &SemiHonestContext<'_, F>,
        record_id: RecordId,
        to_helper: Role,
    ) -> Result<Replicated<F>, Error> {
        let channel = ctx.mesh();
        let prss = ctx.prss();
        let (r0, r1) = prss.generate_fields(record_id);

        // `to_helper.left` calculates part1 = (input.0 + input.1) - r1 and sends part1 to `to_helper.right`
        // This is same as (a1 + a2) - r2 in the diagram
        if ctx.role() == to_helper.peer(Direction::Left) {
            let part1 = self.input.left() + self.input.right() - r1;
            channel
                .send(to_helper.peer(Direction::Right), record_id, part1)
                .await?;

            // Sleep until `to_helper.right` sends us their part2 value
            let part2 = channel
                .receive(to_helper.peer(Direction::Right), record_id)
                .await?;

            Ok(Replicated::new(part1 + part2, r1))
        } else if ctx.role() == to_helper.peer(Direction::Right) {
            // `to_helper.right` calculates part2 = (input.left() - r0) and sends it to `to_helper.left`
            // This is same as (a3 - r3) in the diagram
            let part2 = self.input.left() - r0;
            channel
                .send(to_helper.peer(Direction::Left), record_id, part2)
                .await?;

            // Sleep until `to_helper.left` sends us their part1 value
            let part1: F = channel
                .receive(to_helper.peer(Direction::Left), record_id)
                .await?;

            Ok(Replicated::new(r0, part1 + part2))
        } else {
            Ok(Replicated::new(r0, r1))
        }
    }
}

#[cfg(test)]
mod tests {

    use proptest::prelude::Rng;

    use rand::thread_rng;

    use crate::ff::Fp32BitPrime;
    use crate::protocol::context::Context;
    use crate::{
        helpers::Role,
        protocol::{sort::reshare::Reshare, QueryId, RecordId},
        test_fixture::{make_world, validate_and_reconstruct},
    };

    use crate::test_fixture::Runner;

    /// Validates that reshare protocol actually generates new shares using PRSS.
    #[tokio::test]
    async fn generates_unique_shares() {
        let world = make_world(QueryId);

        for &target in Role::all() {
            let secret = thread_rng().gen::<Fp32BitPrime>();
            let shares = world
                .semi_honest(secret, |ctx, share| async move {
                    let record_id = RecordId::from(0);

                    // run reshare protocol for all helpers except the one that does not know the input
                    if ctx.role() == target {
                        // test follows the reshare protocol
                        ctx.prss().generate_fields(record_id).into()
                    } else {
                        Reshare::new(share.clone())
                            .execute(&ctx, record_id, target)
                            .await
                            .unwrap()
                    }
                })
                .await;

            let reshared_secret = validate_and_reconstruct(&shares[0], &shares[1], &shares[2]);

            // if reshare cheated and just returned its input without adding randomness,
            // this test will catch it with the probability of error (1/|F|)^2.
            // Using 32 bit field is sufficient to consider error probability negligible
            assert_eq!(secret, reshared_secret);
        }
    }

    /// This test validates the correctness of the protocol, relying on `generates_unique_shares`
    /// to ensure security. It does not verify that helpers actually attempt to generate new shares
    /// so a naive implementation of reshare that just output shares `[O]` = `[I]` where `[I]` is
    /// the input will pass this test. However `generates_unique_shares` will fail this implementation.
    #[tokio::test]
    async fn correct() {
        let world = make_world(QueryId);

        for role in Role::all() {
            let secret = thread_rng().gen::<Fp32BitPrime>();
            let new_shares = world
                .semi_honest(secret, |ctx, share| async move {
                    Reshare::new(share)
                        .execute(&ctx, RecordId::from(0), *role)
                        .await
                        .unwrap()
                })
                .await;

            assert_eq!(
                secret,
                validate_and_reconstruct(&new_shares[0], &new_shares[1], &new_shares[2])
            );
        }
    }
}
