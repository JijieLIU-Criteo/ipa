use crate::ff::Field;
use crate::protocol::context::{Context, MaliciousContext};
use crate::secret_sharing::{MaliciousReplicated, SecretSharing};
use crate::{
    error::Error,
    helpers::{Direction, Role},
    protocol::{context::SemiHonestContext, sort::ReshareStep::ReshareMAC, RecordId},
    secret_sharing::Replicated,
};
use async_trait::async_trait;
use embed_doc_image::embed_doc_image;
use futures::future::try_join;

/// Trait for reshare protocol to renew shares of a secret value for all 3 helpers.
#[async_trait]
pub trait Reshare<F: Field> {
    type Share: SecretSharing<F>;

    async fn reshare(
        self,
        input: &Self::Share,
        record: RecordId,
        to_helper: Role,
    ) -> Result<Self::Share, Error>;
}

/// Reshare(i, \[x\])
// This implements semi-honest reshare algorithm of "Efficient Secure Three-Party Sorting Protocol with an Honest Majority" at communication cost of 2R.
// Input: Pi-1 and Pi+1 know their secret shares
// Output: At the end of the protocol, all 3 helpers receive their shares of a new, random secret sharing of the secret value
#[embed_doc_image("reshare", "images/sort/reshare.png")]
/// Steps
/// ![Reshare steps][reshare]
/// 1. While calculating for a helper, we call pseudo random secret sharing (prss) to get random values which match
///    with those generated by other helpers (say `rand_left`, `rand_right`)
///    `to_helper.left` knows `rand_left` (named r1) and `to_helper.right` knows `rand_right` (named r0)
/// 2. `to_helper.left` calculates part1 = (a1 + a2) - r2 = Same as (input.left() + input.right()) - r1 from helper POV
///    `to_helper.right` calculates part2 = (a3 - r3) = Same as (input.left() - r0) from helper POV
/// 3. `to_helper.left` and `to_helper.right` exchange their calculated shares
/// 4. Everyone sets their shares
///    `to_helper.left`  = (part1 + part2, `rand_left`)  = (part1 + part2, r1)
///    `to_helper`       = (`rand_left`, `rand_right`)     = (r0, r1)
///    `to_helper.right` = (`rand_right`, part1 + part2) = (r0, part1 + part2)
#[async_trait]
impl<F: Field> Reshare<F> for SemiHonestContext<'_, F> {
    type Share = Replicated<F>;
    async fn reshare(
        self,
        input: &Self::Share,
        record_id: RecordId,
        to_helper: Role,
    ) -> Result<Self::Share, Error> {
        let channel = self.mesh();
        let prss = self.prss();
        let (r0, r1) = prss.generate_fields(record_id);

        // `to_helper.left` calculates part1 = (input.0 + input.1) - r1 and sends part1 to `to_helper.right`
        // This is same as (a1 + a2) - r2 in the diagram
        if self.role() == to_helper.peer(Direction::Left) {
            let part1 = input.left() + input.right() - r1;
            channel
                .send(to_helper.peer(Direction::Right), record_id, part1)
                .await?;

            // Sleep until `to_helper.right` sends us their part2 value
            let part2 = channel
                .receive(to_helper.peer(Direction::Right), record_id)
                .await?;

            Ok(Replicated::new(part1 + part2, r1))
        } else if self.role() == to_helper.peer(Direction::Right) {
            // `to_helper.right` calculates part2 = (input.left() - r0) and sends it to `to_helper.left`
            // This is same as (a3 - r3) in the diagram
            let part2 = input.left() - r0;
            channel
                .send(to_helper.peer(Direction::Left), record_id, part2)
                .await?;

            // Sleep until `to_helper.left` sends us their part1 value
            let part1: F = channel
                .receive(to_helper.peer(Direction::Left), record_id)
                .await?;

            Ok(Replicated::new(r0, part1 + part2))
        } else {
            Ok(Replicated::new(r0, r1))
        }
    }
}

/// For malicious reshare, we run semi honest reshare protocol twice, once for x and another for rx and return the results
/// # Errors
/// If either of reshares fails
#[async_trait]
impl<F: Field> Reshare<F> for MaliciousContext<'_, F> {
    type Share = MaliciousReplicated<F>;
    async fn reshare(
        self,
        input: &Self::Share,
        record_id: RecordId,
        to_helper: Role,
    ) -> Result<Self::Share, Error> {
        let rx_ctx = self.narrow(&ReshareMAC);
        let (x, rx) = try_join(
            self.to_semi_honest()
                .reshare(input.x(), record_id, to_helper),
            rx_ctx
                .to_semi_honest()
                .reshare(input.rx(), record_id, to_helper),
        )
        .await?;
        Ok(MaliciousReplicated::new(x, rx))
    }
}

#[cfg(test)]
mod tests {
    use proptest::prelude::Rng;
    use rand::rngs::mock::StepRng;

    use crate::{
        ff::Fp31,
        helpers::Role,
        protocol::{sort::reshare::Reshare, QueryId, RecordId},
        test_fixture::{
            join3, make_contexts, make_malicious_contexts, make_world, share, share_malicious,
            validate_and_reconstruct, validate_and_reconstruct_malicious, TestWorld,
        },
    };

    #[tokio::test]
    pub async fn semi_honest() {
        let mut rand = StepRng::new(100, 1);
        let mut rng = rand::thread_rng();
        let mut new_reshares_atleast_once = false;
        let world: TestWorld = make_world(QueryId);
        let [ctx0, ctx1, ctx2] = make_contexts::<Fp31>(&world);

        for _ in 0..10 {
            let secret = rng.gen::<u128>();

            let input = Fp31::from(secret);
            let shares = share(input, &mut rand);
            let record_id = RecordId::from(0);

            let [share0, share1, share2] = shares.clone();

            let h0_future = ctx0.clone().reshare(&share0, record_id, Role::H2);
            let h1_future = ctx1.clone().reshare(&share1, record_id, Role::H2);
            let h2_future = ctx2.clone().reshare(&share2, record_id, Role::H2);

            let f = join3(h0_future, h1_future, h2_future).await;
            let output_share = validate_and_reconstruct(&f[0], &f[1], &f[2]);
            assert_eq!(output_share, input);

            if f[..] != shares[..] {
                new_reshares_atleast_once = true;
                break;
            }
        }
        assert!(new_reshares_atleast_once);
    }

    #[tokio::test]
    pub async fn malicious() {
        let mut rand = StepRng::new(100, 1);
        let mut rng = rand::thread_rng();
        let mut new_reshares_atleast_once = false;
        let world: TestWorld = make_world(QueryId);
        let [ctx0, ctx1, ctx2] = make_malicious_contexts::<Fp31>(&world);
        let r = rng.gen::<Fp31>();

        for _ in 0..10 {
            let secret = rng.gen::<u128>();

            let input = Fp31::from(secret);
            let shares = share_malicious(input, r, &mut rand);
            let record_id = RecordId::from(0);

            let [share0, share1, share2] = shares.clone();

            let h0_future = ctx0.ctx.clone().reshare(&share0, record_id, Role::H2);
            let h1_future = ctx1.ctx.clone().reshare(&share1, record_id, Role::H2);
            let h2_future = ctx2.ctx.clone().reshare(&share2, record_id, Role::H2);

            let f = join3(h0_future, h1_future, h2_future).await;

            validate_and_reconstruct_malicious(r, &f[0], &f[1], &f[2], Some(secret));

            if f[..] != shares[..] {
                new_reshares_atleast_once = true;
                break;
            }
        }
        assert!(new_reshares_atleast_once);
    }
}
